<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earth-Mars Trajectory Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use Inter font */
        body {
            font-family: 'Inter', sans-serif;
            /* Removed overflow: hidden to allow scrolling */
        }
        /* Style canvas */
        canvas {
            display: block;
            background-color: #00001a; /* Dark space background - stays dark */
            border-radius: 0.5rem; /* Rounded corners */
            border: 1px solid #4a5568; /* Add a subtle border */
            max-width: 100%;
            max-height: 100%;
        }
        /* Ensure layout fits screen height initially */
        html, body {
            height: 100%;
            margin: 0;
        }
        /* Main container setup */
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; /* Use min-height to allow content to expand */
            /* Removed fixed height: 100vh */
            padding: 1rem;
        }
        /* Wrapper for canvas to control flex growth and centering */
        .canvas-wrapper {
            flex-grow: 1; /* Allow this div to take up available vertical space */
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 0;
            min-height: 300px; /* Ensure canvas wrapper has a minimum height */
        }
         /* Styling for the controls area below canvas */
        .controls {
            flex-shrink: 0; /* Prevent controls area from shrinking */
            padding-top: 0.5rem;
            text-align: center;
        }
        /* Styling for the description section */
        .description {
            flex-shrink: 0; /* Prevent description from shrinking */
            margin-top: 2rem; /* More space above description */
            padding: 1rem; /* Padding inside the box */
            border-radius: 0.5rem; /* Rounded corners */
        }

    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
     <script>
        // On page load or when changing themes, best to add inline in `head` to avoid FOUC
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
          document.documentElement.classList.add('dark')
        } else {
          document.documentElement.classList.remove('dark')
        }
     </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white transition-colors duration-300">
    <div class="container mx-auto">
        <h1 class="text-2xl font-bold text-center flex-shrink-0 mb-2">Earth to Mars Hohmann Transfer Simulation</h1>

        <div class="canvas-wrapper">
            <canvas id="orbitCanvas" class="rounded-lg shadow-lg"></canvas>
        </div>

        <div class="controls w-full max-w-md mx-auto">
             <p id="travelTime" class="font-semibold text-sm md:text-base">Calculating travel time...</p>
             <p id="status" class="mt-1 text-sm text-yellow-600 dark:text-yellow-400"></p>
             <button id="startSimButton" class="mt-2 px-5 py-2 bg-blue-600 dark:bg-blue-700 hover:bg-blue-700 dark:hover:bg-blue-800 rounded-lg text-white font-semibold shadow transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                 Start Simulation
             </button>
        </div>

        <div class="description w-full max-w-2xl mx-auto bg-gray-200 dark:bg-gray-800 text-gray-700 dark:text-gray-300 text-sm">
            <h2 class="text-lg font-semibold mb-2 text-gray-900 dark:text-white">Simulation Details</h2>
            <p>This simulation shows a simplified <strong class="font-semibold text-gray-800 dark:text-gray-100">Hohmann transfer orbit</strong>, an energy-efficient way to travel between two circular, coplanar orbits (like Earth and Mars, approximated).</p>
            <p class="mt-1">The spacecraft follows an elliptical path that touches Earth's orbit at its start (periapsis) and Mars' orbit at its end (apoapsis). The travel time is half the orbital period of this transfer ellipse.</p>
            <p class="mt-3"><strong class="font-semibold text-gray-800 dark:text-gray-100">Assumptions:</strong></p>
            <ul class="list-disc list-inside mt-1 space-y-1">
                <li>Circular orbits for Earth and Mars.</li>
                <li>Orbits are in the same plane (coplanar).</li>
                <li>Speed changes (burns) to enter and exit the transfer orbit are instantaneous.</li>
                <li>Gravitational effects of planets other than the Sun are ignored during the transfer.</li>
            </ul>
        </div>

        <p class="text-center text-sm text-gray-500 dark:text-gray-400">
            &copy; <span id="copyright-year"></span> NakedCircuits All rights reserved.
        </p>
    </div>

    <script>
        // --- Constants and Setup ---
        const canvas = document.getElementById('orbitCanvas');
        const canvasWrapper = canvas.parentElement; // Get the wrapper div
        const ctx = canvas.getContext('2d');
        const travelTimeElement = document.getElementById('travelTime');
        const statusElement = document.getElementById('status');
        const startButton = document.getElementById('startSimButton');

        // Astronomical constants
        const AU = 1.496e11;
        const G = 6.67430e-11;
        const M_SUN = 1.989e30;
        const MU_SUN = G * M_SUN;

        // Orbital parameters
        const R_EARTH = 1.0 * AU;
        const R_MARS = 1.524 * AU;

        // Simulation parameters
        let width, height, centerX, centerY;
        let scaledRadiusEarth, scaledRadiusMars;
        let earthAngle = Math.PI;
        let spacecraftAngle = earthAngle;
        let spacecraftRadius;
        let animationFrameId = null;
        let simulationRunning = false;
        let time = 0;
        const timeStep = (24 * 3600) / 2; // 0.5 day step

        let spacecraftTrail = [];

        // --- Hohmann Transfer Calculations ---
        const a_hohmann = (R_EARTH + R_MARS) / 2;
        const T_hohmann = 2 * Math.PI * Math.sqrt(Math.pow(a_hohmann, 3) / MU_SUN);
        const travelTimeSeconds = T_hohmann / 2;
        const travelTimeDays = travelTimeSeconds / (60 * 60 * 24);

        // Check if element exists before setting text content
        if (travelTimeElement) {
            travelTimeElement.textContent = `Approx. Hohmann Transfer Time: ${travelTimeDays.toFixed(1)} days`;
        }

        const omega_earth = Math.sqrt(MU_SUN / Math.pow(R_EARTH, 3));
        const omega_mars = Math.sqrt(MU_SUN / Math.pow(R_MARS, 3));

        // --- Canvas Drawing Functions ---
        function resizeCanvas() {
             // Ensure wrapper exists
            if (!canvasWrapper) return;

            const wrapperWidth = canvasWrapper.clientWidth;
            const wrapperHeight = canvasWrapper.clientHeight; // Use full clientHeight

            // Check for valid dimensions
            if (wrapperWidth <= 0 || wrapperHeight <= 0) return;

            const aspectRatio = 1.2;
            let potentialWidth = wrapperWidth;
            let potentialHeight = wrapperWidth / aspectRatio;

            if (potentialHeight > wrapperHeight) {
                potentialHeight = wrapperHeight;
                potentialWidth = wrapperHeight * aspectRatio;
            }

            width = Math.max(200, Math.min(wrapperWidth, potentialWidth));
            height = Math.max(150, Math.min(wrapperHeight, potentialHeight));

            canvas.width = width;
            canvas.height = height;
            centerX = width / 2;
            centerY = height / 2;

            const newScale = Math.min(centerX, centerY) / (R_MARS * 1.15);

            // Check if scale is valid
            if (!isFinite(newScale) || newScale <= 0) return;

            scaledRadiusEarth = R_EARTH * newScale;
            scaledRadiusMars = R_MARS * newScale;

            if (!simulationRunning) {
                 spacecraftRadius = scaledRadiusEarth;
                 spacecraftAngle = earthAngle;
            }

            drawStaticElements();
            drawMovingElements(time);
        }

        function drawCircle(x, y, radius, color) {
            if (!isFinite(x) || !isFinite(y) || !isFinite(radius)) return;
            ctx.beginPath();
            ctx.arc(x, y, Math.max(0, radius), 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
        }

        function drawOrbit(radius, color) {
            if (!isFinite(radius) || radius <= 0) return;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawHohmannTransfer() {
             if (!isFinite(scaledRadiusEarth) || !isFinite(scaledRadiusMars) || scaledRadiusEarth <= 0 || scaledRadiusMars <= 0) return;

            const scaled_a_hohmann = (scaledRadiusEarth + scaledRadiusMars) / 2;
            const c = Math.max(0, scaled_a_hohmann - scaledRadiusEarth);
            const b_hohmann_sq = scaled_a_hohmann**2 - c**2;
            const b_hohmann = b_hohmann_sq > 0 ? Math.sqrt(b_hohmann_sq) : 0;

            if (b_hohmann <= 0 || scaled_a_hohmann <= 0) return;

            ctx.beginPath();
            const ellipseCenterX = centerX - c;
            const ellipseCenterY = centerY;

             if (isFinite(ellipseCenterX) && isFinite(ellipseCenterY) && isFinite(scaled_a_hohmann) && isFinite(b_hohmann)) {
                 ctx.ellipse(ellipseCenterX, ellipseCenterY, scaled_a_hohmann, b_hohmann, 0, 0, 2 * Math.PI);
                 ctx.strokeStyle = 'yellow';
                 ctx.lineWidth = 1.5;
                 ctx.setLineDash([8, 4]);
                 ctx.stroke();
                 ctx.setLineDash([]);
            }
        }

        function drawTrail() {
            if (spacecraftTrail.length < 2) return;
            ctx.beginPath();
            if (isFinite(spacecraftTrail[0].x) && isFinite(spacecraftTrail[0].y)) {
                ctx.moveTo(spacecraftTrail[0].x, spacecraftTrail[0].y);
            } else {
                return;
            }
            for (let i = 1; i < spacecraftTrail.length; i++) {
                if (isFinite(spacecraftTrail[i].x) && isFinite(spacecraftTrail[i].y)) {
                     ctx.lineTo(spacecraftTrail[i].x, spacecraftTrail[i].y);
                }
            }
            ctx.strokeStyle = 'rgba(190, 255, 190, 0.6)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        function drawStaticElements() {
             // Check if context exists and canvas has dimensions
             if (!ctx || !width || !height) return;
             ctx.clearRect(0, 0, width, height);
             drawCircle(centerX, centerY, Math.max(4, width * 0.02), 'orange'); // Sun
             drawOrbit(scaledRadiusEarth, 'rgba(0, 150, 255, 0.5)'); // Earth Orbit
             drawOrbit(scaledRadiusMars, 'rgba(255, 100, 50, 0.5)'); // Mars Orbit
             drawHohmannTransfer();
        }

        function drawMovingElements(currentTime) {
             // Check dependencies
             if (!isFinite(currentTime) || !isFinite(earthAngle) || !isFinite(omega_earth) || !isFinite(omega_mars) || !isFinite(travelTimeSeconds)) return;

             const currentEarthAngle = earthAngle + omega_earth * currentTime;
             const travelAngleMars = omega_mars * travelTimeSeconds;
             const initialMarsAngle = earthAngle + Math.PI - travelAngleMars;
             const currentMarsAngle = initialMarsAngle + omega_mars * currentTime;

             const fractionOfTravel = Math.min(1.0, currentTime / travelTimeSeconds);
             let currentSpacecraftAngle = earthAngle;
             let currentSpacecraftRadius = scaledRadiusEarth;
             let spacecraftX = centerX + currentSpacecraftRadius * Math.cos(currentSpacecraftAngle);
             let spacecraftY = centerY + currentSpacecraftRadius * Math.sin(currentSpacecraftAngle);


             if (currentTime > 0 && currentTime <= travelTimeSeconds) {
                 const a_h = (scaledRadiusEarth + scaledRadiusMars) / 2;
                 const e = (scaledRadiusMars - scaledRadiusEarth) / (scaledRadiusMars + scaledRadiusEarth);
                 const meanAnomaly = Math.PI * fractionOfTravel;
                 const theta = meanAnomaly;
                 currentSpacecraftAngle = earthAngle + theta;
                 const denominator = (1 + e * Math.cos(theta));

                 if (denominator > 1e-6 && isFinite(a_h) && isFinite(e)) {
                    currentSpacecraftRadius = a_h * (1 - e * e) / denominator;
                 } else {
                    currentSpacecraftRadius = scaledRadiusMars;
                 }
                 currentSpacecraftRadius = isFinite(currentSpacecraftRadius) ? currentSpacecraftRadius : scaledRadiusMars;

                 spacecraftX = centerX + currentSpacecraftRadius * Math.cos(currentSpacecraftAngle);
                 spacecraftY = centerY + currentSpacecraftRadius * Math.sin(currentSpacecraftAngle);

                 if (simulationRunning && isFinite(spacecraftX) && isFinite(spacecraftY)) {
                    spacecraftTrail.push({ x: spacecraftX, y: spacecraftY });
                 }

             } else if (currentTime > travelTimeSeconds) {
                 currentSpacecraftAngle = earthAngle + Math.PI;
                 currentSpacecraftRadius = scaledRadiusMars;
                 spacecraftX = centerX + currentSpacecraftRadius * Math.cos(currentSpacecraftAngle);
                 spacecraftY = centerY + currentSpacecraftRadius * Math.sin(currentSpacecraftAngle);

                 if (simulationRunning && spacecraftTrail.length > 0 && isFinite(spacecraftX) && isFinite(spacecraftY)) {
                     const lastPoint = spacecraftTrail[spacecraftTrail.length - 1];
                     if (isFinite(lastPoint?.x) && isFinite(lastPoint?.y) && (lastPoint.x !== spacecraftX || lastPoint.y !== spacecraftY)) {
                         spacecraftTrail.push({ x: spacecraftX, y: spacecraftY });
                     }
                 }
             }

             if(simulationRunning){
                spacecraftAngle = currentSpacecraftAngle;
                spacecraftRadius = currentSpacecraftRadius;
             }

             drawTrail();

             const earthX = centerX + scaledRadiusEarth * Math.cos(currentEarthAngle);
             const earthY = centerY + scaledRadiusEarth * Math.sin(currentEarthAngle);
             drawCircle(earthX, earthY, Math.max(3, width * 0.015), 'blue'); // Earth

             const marsX = centerX + scaledRadiusMars * Math.cos(currentMarsAngle);
             const marsY = centerY + scaledRadiusMars * Math.sin(currentMarsAngle);
             drawCircle(marsX, marsY, Math.max(2.5, width * 0.012), 'red'); // Mars

             if (currentTime > 0) {
                 drawCircle(spacecraftX, spacecraftY, Math.max(2, width * 0.008), 'lime'); // Spacecraft
             }

             if (statusElement) {
                 if (!simulationRunning && currentTime === 0) {
                     statusElement.textContent = "Ready to launch.";
                 }
             }
        }

        function animate() {
            if (!simulationRunning) return;

            drawStaticElements();
            drawMovingElements(time);

            if (time >= travelTimeSeconds) {
                 simulationRunning = false;
                 if (statusElement) statusElement.textContent = `Arrived at Mars orbit in ~${(time / (3600*24)).toFixed(1)} days!`;
                 if (startButton) {
                     startButton.disabled = false;
                     startButton.textContent = "Restart Simulation";
                 }
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                 drawStaticElements();
                 drawMovingElements(time);
            } else {
                 time += timeStep;
                 animationFrameId = requestAnimationFrame(animate);
            }
        }

        // --- Event Listeners ---
        if (startButton) {
            startButton.addEventListener('click', () => {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                time = 0;
                earthAngle = Math.PI;
                spacecraftTrail = [];
                resizeCanvas(); // Recalculate sizes first
                // Ensure radii/angles are valid after resize before setting start pos
                if (!isFinite(scaledRadiusEarth) || !isFinite(earthAngle)) return; // Safety check
                spacecraftAngle = earthAngle;
                spacecraftRadius = scaledRadiusEarth;

                simulationRunning = true;
                startButton.disabled = true;
                startButton.textContent = "Simulation Running...";
                if (statusElement) statusElement.textContent = "Launch initiated...";

                const startX = centerX + scaledRadiusEarth * Math.cos(earthAngle);
                const startY = centerY + scaledRadiusEarth * Math.sin(earthAngle);
                 if (isFinite(startX) && isFinite(startY)) {
                     spacecraftTrail.push({ x: startX, y: startY });
                 }
                animate();
            });
        }

        // Use ResizeObserver
        const resizeObserver = new ResizeObserver(entries => {
            resizeCanvas();
        });
        if (canvasWrapper) {
            resizeObserver.observe(canvasWrapper);
        }


        // --- Initial Setup ---
        if (canvasWrapper) {
             // Delay initial resize slightly more to ensure layout is stable
             setTimeout(resizeCanvas, 50);
        } else {
            console.error("Canvas wrapper not found for initial resize.");
        }

    </script>
</body>
</html>
