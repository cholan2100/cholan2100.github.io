<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frame of Reference Explained</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic styling for canvas elements */
        canvas {
            border: 1px solid #ccc;
            border-radius: 0.5rem; /* Rounded corners */
            background-color: #f0f9ff; /* Light blue background */
            display: block; /* Ensure canvas takes block space */
            margin-left: auto;
            margin-right: auto;
            /* Add dark mode border */
            border-color: #e5e7eb; /* Default light border */
        }
        /* Dark mode specific canvas styles */
        .dark canvas {
             background-color: #1f2937; /* Darker background for canvas in dark mode */
             border-color: #4b5563; /* Darker border */
        }

        /* Button styling */
        .sim-button {
            padding: 0.5rem 1rem;
            margin: 0.5rem 0.25rem;
            border-radius: 0.375rem; /* Rounded corners */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .sim-button:hover {
            opacity: 0.9;
        }
        .play-button {
            background-color: #22c55e; /* Green */
            color: white;
        }
        .reset-button {
            background-color: #f97316; /* Orange */
            color: white;
        }
        /* Dark mode button adjustments */
        .dark .play-button {
             background-color: #16a34a;
        }
         .dark .reset-button {
             background-color: #ea580c;
        }

    </style>
</head>
<body class="font-sans bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-200 p-4 md:p-8 transition-colors duration-300 overflow-x-hidden">

    <div class="max-w-4xl mx-auto bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md dark:shadow-lg transition-colors duration-300">

        <h1 class="text-3xl font-bold mb-4 text-center text-blue-700 dark:text-blue-400">Understanding Frame of Reference</h1>

        <p class="mb-6 text-lg text-gray-700 dark:text-gray-300">
            In physics, a <strong>frame of reference</strong> is a coordinate system or a set of axes used to measure the position, orientation, and other properties of objects. How we perceive motionâ€”like speed and trajectoryâ€”depends entirely on the frame of reference we choose. An <strong>inertial frame of reference</strong> is one where Newton's first law (the law of inertia) holds true; essentially, it's a frame that is not accelerating. Let's explore this with some simulations.
        </p>

        <div class="mb-8 p-4 border border-gray-200 dark:border-gray-700 rounded-lg bg-sky-50 dark:bg-sky-900/50 transition-colors duration-300">
            <h2 class="text-2xl font-semibold mb-3 text-center text-blue-600 dark:text-blue-400">Simulation 1: Stationary Frame</h2>
            <canvas id="sim1Canvas" width="600" height="300" class="mb-3"></canvas>
            <div class="text-center mb-3">
                <button id="playSim1" class="sim-button play-button">Play</button>
                <button id="resetSim1" class="sim-button reset-button">Reset</button>
            </div>
            <p class="text-gray-600 dark:text-gray-400 text-center">
                <strong>Description:</strong> Here, both stick figures are in the same stationary frame of reference. Since it's not accelerating, this is an <strong>inertial frame</strong>. The blue figure throws a ball straight up. Both observers in this inertial frame see the ball go vertically up and come straight back down. The trajectory trace confirms this shared observation.
            </p>
        </div>

        <div class="mb-8 p-4 border border-gray-200 dark:border-gray-700 rounded-lg bg-lime-50 dark:bg-lime-900/50 transition-colors duration-300">
            <h2 class="text-2xl font-semibold mb-3 text-center text-green-600 dark:text-green-400">Simulation 2: Moving Frame (Internal Observers)</h2>
            <canvas id="sim2Canvas" width="600" height="300" class="mb-3"></canvas>
             <div class="text-center mb-3">
                <button id="playSim2" class="sim-button play-button">Play</button>
                <button id="resetSim2" class="sim-button reset-button">Reset</button>
            </div>
            <p class="text-gray-600 dark:text-gray-400 text-center">
                <strong>Description:</strong> This simulation shows a frame of reference moving at a constant velocity (the bus). Because there is no acceleration, this moving frame is also an <strong>inertial frame</strong>. Both stick figures are inside. The blue figure throws the ball straight up *relative to the bus*. From their perspective *within this inertial frame*, both figures observe the ball going vertically up and down. The trajectory trace relative to them is a straight vertical line. Notice the wheels spinning!
            </p>
        </div>

        <div class="mb-8 p-4 border border-gray-200 dark:border-gray-700 rounded-lg bg-amber-50 dark:bg-amber-900/50 transition-colors duration-300">
            <h2 class="text-2xl font-semibold mb-3 text-center text-orange-600 dark:text-orange-400">Simulation 3: Moving vs. Stationary Frame</h2>
            <canvas id="sim3Canvas" width="600" height="300" class="mb-3"></canvas>
             <div class="text-center mb-3">
                <button id="playSim3" class="sim-button play-button">Play Throw</button>
                <button id="resetSim3" class="sim-button reset-button">Reset Simulation</button>
            </div>
            <p class="text-gray-600 dark:text-gray-400 text-center">
                <strong>Description:</strong> Now, we compare observations from two different inertial frames: the moving bus (with spinning wheels) and the stationary ground. The blue figure is inside the moving bus, and the red figure is stationary on the ground. Press "Play Throw" to make the blue figure throw the ball straight up *relative to the bus's current position*.
                <br>ðŸ”µ <strong class="text-blue-700 dark:text-blue-400">Observer in Bus:</strong> Sees the ball go vertically up and down (blue dashed line).
                <br>ðŸ”´ <strong class="text-red-700 dark:text-red-400">Observer on Ground:</strong> Sees the ball follow a parabolic path (red dashed line) because the ball has both vertical motion (from the throw) and horizontal motion (from the bus). Pressing "Play Throw" again starts a new throw, clearing old trajectories.
            </p>
        </div>

    </div>

    <script>
        // --- Theme Detection ---
        const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (isDarkMode) {
            document.documentElement.classList.add('dark');
        }
         window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) { document.documentElement.classList.add('dark'); }
            else { document.documentElement.classList.remove('dark'); }
             resetSimulation1();
             resetSimulation2();
             const wasRunningSim2 = animationFrameId2 != null; // Check if sim 2 was running
             const wasRunningSim3 = sim3Running;
             resetSimulation3(); // Resets state
             drawSim3(); // Draw reset state for sim3
             // Restart animations if they were running before theme change
             if(wasRunningSim2 && bus2.vx !== 0) animateSim2();
             if(wasRunningSim3 && bus3.vx !== 0) animateSim3();
        });

        // --- Utility Functions ---
        function drawStickFigure(ctx, x, y, color = 'black') {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.strokeStyle = isDark ? (color === 'blue' ? '#60a5fa' : color === 'green' ? '#4ade80' : color === 'red' ? '#f87171' : '#e5e7eb') : color;
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(x, y - 40, 10, 0, Math.PI * 2); ctx.stroke(); // Head
            ctx.beginPath(); ctx.moveTo(x, y - 30); ctx.lineTo(x, y - 10); ctx.stroke(); // Body
            ctx.beginPath(); ctx.moveTo(x - 10, y - 25); ctx.lineTo(x + 10, y - 25); ctx.stroke(); // Arms
            ctx.beginPath(); ctx.moveTo(x, y - 10); ctx.lineTo(x - 10, y); ctx.moveTo(x, y - 10); ctx.lineTo(x + 10, y); ctx.stroke(); // Legs
        }

        function drawGround(ctx, y) {
            const isDark = document.documentElement.classList.contains('dark');
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(ctx.canvas.width, y);
            ctx.strokeStyle = isDark ? '#ca8a04' : '#a16207';
            ctx.lineWidth = 3; ctx.stroke();
        }

        // UPDATED drawBusOutline to include wheelAngle for spinning effect
        function drawBusOutline(ctx, x, y, width, height, wheelAngle) {
             const isDark = document.documentElement.classList.contains('dark');
             // Bus Body
             ctx.strokeStyle = isDark ? '#9ca3af' : '#6b7280';
             ctx.lineWidth = 2;
             ctx.strokeRect(x, y, width, height);

             // Wheels
             const wheelRadius = 8;
             const wheelY = y + height + 5;
             const wheelX1 = x + width * 0.2;
             const wheelX2 = x + width * 0.8;
             // Brighter gray for dark mode wheels, dark gray for light mode
             ctx.fillStyle = isDark ? '#9ca3af' : '#374151';

             // Spoke Color: Light gray on dark wheel, medium gray on light wheel
             const spokeColor = isDark ? '#e5e7eb' : '#6b7280';
             ctx.strokeStyle = spokeColor;
             ctx.lineWidth = 1.5; // Thinner line for spoke

             // Draw wheel 1 & spoke
             ctx.beginPath(); ctx.arc(wheelX1, wheelY, wheelRadius, 0, Math.PI * 2); ctx.fill();
             ctx.beginPath(); ctx.moveTo(wheelX1, wheelY); // Spoke center
             ctx.lineTo(wheelX1 + wheelRadius * Math.cos(wheelAngle), wheelY + wheelRadius * Math.sin(wheelAngle)); // Spoke edge
             ctx.stroke();

             // Draw wheel 2 & spoke
             ctx.beginPath(); ctx.arc(wheelX2, wheelY, wheelRadius, 0, Math.PI * 2); ctx.fill();
             ctx.beginPath(); ctx.moveTo(wheelX2, wheelY); // Spoke center
             ctx.lineTo(wheelX2 + wheelRadius * Math.cos(wheelAngle), wheelY + wheelRadius * Math.sin(wheelAngle)); // Spoke edge
             ctx.stroke();
        }

        function getTrajectoryColor(baseColor) { /* ... (no changes) ... */
             const isDark = document.documentElement.classList.contains('dark');
             if (isDark) { return baseColor === 'blue' ? '#60a5fa' : baseColor === 'red' ? '#f87171' : '#cbd5e1'; }
             else { return baseColor; }
        }
        function getBallColor(simNumber) { /* ... (no changes) ... */
             const isDark = document.documentElement.classList.contains('dark');
             if (isDark) { return simNumber === 3 ? '#fb923c' : '#f87171'; }
             else { return simNumber === 3 ? 'orange' : 'red'; }
        }

        // --- Simulation 1: Stationary Frame ---
        /* ... (No changes in Sim 1 logic) ... */
        const canvas1 = document.getElementById('sim1Canvas');
        const ctx1 = canvas1.getContext('2d');
        const playSim1 = document.getElementById('playSim1');
        const resetSim1 = document.getElementById('resetSim1');
        let ball1 = { x: 150, y: 250, vy: 0, radius: 8 };
        let thrower1Pos = { x: 150, y: 290 };
        let observer1Pos = { x: 450, y: 290 };
        let isThrowing1 = false;
        let gravity1 = 0.2;
        let initialVelocity1 = -7;
        let trajectory1 = [];
        let animationFrameId1;
        function resetSimulation1() { cancelAnimationFrame(animationFrameId1); animationFrameId1 = null; isThrowing1 = false; ball1 = { x: thrower1Pos.x, y: thrower1Pos.y - 50, vy: 0, radius: 8 }; trajectory1 = []; drawSim1(); }
        function drawSim1() { ctx1.clearRect(0, 0, canvas1.width, canvas1.height); drawGround(ctx1, 295); drawStickFigure(ctx1, thrower1Pos.x, thrower1Pos.y, 'blue'); drawStickFigure(ctx1, observer1Pos.x, observer1Pos.y, 'green'); ctx1.beginPath(); ctx1.arc(ball1.x, ball1.y, ball1.radius, 0, Math.PI * 2); ctx1.fillStyle = getBallColor(1); ctx1.fill(); if (trajectory1.length > 1) { ctx1.beginPath(); ctx1.moveTo(trajectory1[0].x, trajectory1[0].y); for (let i = 1; i < trajectory1.length; i++) { ctx1.lineTo(trajectory1[i].x, trajectory1[i].y); } ctx1.strokeStyle = getTrajectoryColor('blue'); ctx1.setLineDash([4, 2]); ctx1.lineWidth = 1.5; ctx1.stroke(); ctx1.setLineDash([]); } }
        function animateSim1() { if (!isThrowing1) { animationFrameId1 = null; return; } ball1.vy += gravity1; ball1.y += ball1.vy; trajectory1.push({ x: ball1.x, y: ball1.y }); if (ball1.y >= thrower1Pos.y - 50 && ball1.vy > 0) { ball1.y = thrower1Pos.y - 50; isThrowing1 = false; ball1.vy = 0; } drawSim1(); if (isThrowing1) { animationFrameId1 = requestAnimationFrame(animateSim1); } else { animationFrameId1 = null; } }
        playSim1.onclick = () => { if (!isThrowing1) { resetSimulation1(); isThrowing1 = true; ball1.vy = initialVelocity1; trajectory1.push({ x: ball1.x, y: ball1.y }); if (!animationFrameId1) { animateSim1(); } } };
        resetSim1.onclick = resetSimulation1;


        // --- Simulation 2: Moving Frame (Internal) ---
        const canvas2 = document.getElementById('sim2Canvas');
        const ctx2 = canvas2.getContext('2d');
        const playSim2 = document.getElementById('playSim2');
        const resetSim2 = document.getElementById('resetSim2');
        let bus2 = { x: 50, y: 50, width: 300, height: 200, vx: 1.5 };
        let thrower2PosRel = { x: 75, y: bus2.height - 10 };
        let observer2PosRel = { x: 225, y: bus2.height - 10 };
        let ball2 = { xRel: thrower2PosRel.x, yRel: thrower2PosRel.y - 50, vy: 0, radius: 8 };
        let isThrowing2 = false;
        let gravity2 = 0.2;
        let initialVelocity2 = -7;
        let trajectory2Rel = [];
        let animationFrameId2;
        let wheelAngle2 = 0; // Added wheel angle state for Sim 2

        function resetSimulation2() {
             cancelAnimationFrame(animationFrameId2);
             animationFrameId2 = null;
             isThrowing2 = false;
             bus2.x = 50;
             ball2 = { xRel: thrower2PosRel.x, yRel: thrower2PosRel.y - 50, vy: 0, radius: 8 };
             trajectory2Rel = [];
             wheelAngle2 = 0; // Reset wheel angle
             drawSim2();
        }

        function drawSim2() {
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            drawGround(ctx2, 295);
            const throwerAbsX = bus2.x + thrower2PosRel.x;
            const throwerAbsY = bus2.y + thrower2PosRel.y;
            const observerAbsX = bus2.x + observer2PosRel.x;
            const observerAbsY = bus2.y + observer2PosRel.y;
            const ballAbsX = bus2.x + ball2.xRel;
            const ballAbsY = bus2.y + ball2.yRel;
            // Pass wheelAngle2 to drawBusOutline
            drawBusOutline(ctx2, bus2.x, bus2.y, bus2.width, bus2.height, wheelAngle2);
            drawStickFigure(ctx2, throwerAbsX, throwerAbsY, 'blue');
            drawStickFigure(ctx2, observerAbsX, observerAbsY, 'green');
            ctx2.beginPath(); ctx2.arc(ballAbsX, ballAbsY, ball2.radius, 0, Math.PI * 2); ctx2.fillStyle = getBallColor(2); ctx2.fill();
            if (trajectory2Rel.length > 1) {
                ctx2.beginPath(); ctx2.moveTo(bus2.x + trajectory2Rel[0].x, bus2.y + trajectory2Rel[0].y);
                for (let i = 1; i < trajectory2Rel.length; i++) { ctx2.lineTo(bus2.x + trajectory2Rel[i].x, bus2.y + trajectory2Rel[i].y); }
                ctx2.strokeStyle = getTrajectoryColor('blue'); ctx2.setLineDash([4, 2]); ctx2.lineWidth = 1.5; ctx2.stroke(); ctx2.setLineDash([]);
            }
        }

        function animateSim2() {
             // Update wheel angle based on bus velocity
             wheelAngle2 += bus2.vx * 0.1; // Adjust 0.1 for spin speed

             // Move bus
             bus2.x += bus2.vx;
             if (bus2.x > canvas2.width) { // Wrap bus
                 bus2.x = -bus2.width;
             } else if (bus2.x < -bus2.width) { // Handle negative velocity wrap
                bus2.x = canvas2.width;
             }

             // Ball physics
             if (isThrowing2) { /* ... (ball logic unchanged) ... */
                ball2.vy += gravity2;
                ball2.yRel += ball2.vy;
                trajectory2Rel.push({ x: ball2.xRel, y: ball2.yRel });
                if (ball2.yRel >= thrower2PosRel.y - 50 && ball2.vy > 0) {
                    ball2.yRel = thrower2PosRel.y - 50;
                    isThrowing2 = false;
                    ball2.vy = 0;
                }
             }
             drawSim2(); // Redraw with updated positions and wheel angle
             if(isThrowing2 || bus2.vx !== 0) {
                  animationFrameId2 = requestAnimationFrame(animateSim2);
             } else {
                  animationFrameId2 = null;
             }
        }

         playSim2.onclick = () => { /* ... (onclick logic unchanged) ... */
            if (!isThrowing2) {
                 if (!animationFrameId2) { bus2.x = 50; wheelAngle2 = 0; } // Reset angle if restarting
                 isThrowing2 = true;
                 ball2.yRel = thrower2PosRel.y - 50;
                 ball2.vy = initialVelocity2;
                 trajectory2Rel = [];
                 trajectory2Rel.push({ x: ball2.xRel, y: ball2.yRel });
                 if (!animationFrameId2) { animateSim2(); }
            }
         };
         resetSim2.onclick = resetSimulation2;


        // --- Simulation 3: Moving vs. Stationary Frame ---
        const canvas3 = document.getElementById('sim3Canvas');
        const ctx3 = canvas3.getContext('2d');
        const playSim3 = document.getElementById('playSim3');
        const resetSim3 = document.getElementById('resetSim3');
        let bus3 = { x: 50, y: 50, width: 200, height: 200, vx: 1.5 };
        let thrower3PosRel = { x: 50, y: bus3.height - 10 };
        let observer3PosAbs = { x: 500, y: 290 };
        let ball3 = { xAbs: bus3.x + thrower3PosRel.x, yRel: thrower3PosRel.y - 50, vy: 0, vx: bus3.vx, radius: 8 };
        let isThrowing3 = false;
        let gravity3 = 0.2;
        let initialVelocity3 = -7;
        let trajectory3RelBus = [];
        let trajectory3AbsGround = [];
        let animationFrameId3;
        let sim3Running = false;
        let wheelAngle3 = 0; // Added wheel angle state for Sim 3

        function resetSimulation3() {
            cancelAnimationFrame(animationFrameId3);
            animationFrameId3 = null;
            sim3Running = false;
            isThrowing3 = false;
            bus3.x = 50;
            ball3 = { xAbs: bus3.x + thrower3PosRel.x, yRel: thrower3PosRel.y - 50, vy: 0, vx: bus3.vx, radius: 8 };
            trajectory3RelBus = [];
            trajectory3AbsGround = [];
            wheelAngle3 = 0; // Reset wheel angle
            // Don't draw here, let the caller handle drawing or restarting animation
        }

        function drawSim3() {
            ctx3.clearRect(0, 0, canvas3.width, canvas3.height);
            drawGround(ctx3, 295);
            const throwerAbsX = bus3.x + thrower3PosRel.x;
            const throwerAbsY = bus3.y + thrower3PosRel.y;
            const ballAbsY = bus3.y + ball3.yRel;
            // Pass wheelAngle3 to drawBusOutline
            drawBusOutline(ctx3, bus3.x, bus3.y, bus3.width, bus3.height, wheelAngle3);
            drawStickFigure(ctx3, throwerAbsX, throwerAbsY, 'blue');
            drawStickFigure(ctx3, observer3PosAbs.x, observer3PosAbs.y, 'red');
            if (isThrowing3 || trajectory3AbsGround.length > 0) {
                 ctx3.beginPath(); ctx3.arc(ball3.xAbs, ballAbsY, ball3.radius, 0, Math.PI * 2); ctx3.fillStyle = getBallColor(3); ctx3.fill();
            }
            if (trajectory3RelBus.length > 1) { // Draw relative trajectory
                ctx3.beginPath(); ctx3.moveTo(bus3.x + trajectory3RelBus[0].x, bus3.y + trajectory3RelBus[0].y);
                for (let i = 1; i < trajectory3RelBus.length; i++) { ctx3.lineTo(bus3.x + trajectory3RelBus[i].x, bus3.y + trajectory3RelBus[i].y); }
                ctx3.strokeStyle = getTrajectoryColor('blue'); ctx3.setLineDash([4, 2]); ctx3.lineWidth = 1.5; ctx3.stroke(); ctx3.setLineDash([]);
            }
             if (trajectory3AbsGround.length > 1) { // Draw absolute trajectory
                ctx3.beginPath(); ctx3.moveTo(trajectory3AbsGround[0].x, trajectory3AbsGround[0].y);
                for (let i = 1; i < trajectory3AbsGround.length; i++) { ctx3.lineTo(trajectory3AbsGround[i].x, trajectory3AbsGround[i].y); }
                ctx3.strokeStyle = getTrajectoryColor('red'); ctx3.setLineDash([5, 3]); ctx3.lineWidth = 1.5; ctx3.stroke(); ctx3.setLineDash([]);
            }
        }

        function animateSim3() {
            sim3Running = true;
            let busMoved = false;

            // Update wheel angle based on bus velocity
            wheelAngle3 += bus3.vx * 0.1; // Adjust 0.1 for spin speed

            // Move bus
            if (bus3.vx !== 0) { /* ... (bus movement logic unchanged) ... */
                 bus3.x += bus3.vx;
                 if (bus3.x > canvas3.width + bus3.width) { bus3.x = -bus3.width; }
                 else if (bus3.x < -bus3.width) { bus3.x = canvas3.width; }
                 busMoved = true;
            }

            // Ball physics
            if (isThrowing3) { /* ... (ball logic unchanged) ... */
                ball3.vy += gravity3;
                ball3.yRel += ball3.vy;
                ball3.xAbs += ball3.vx;
                trajectory3RelBus.push({ x: thrower3PosRel.x, y: ball3.yRel });
                trajectory3AbsGround.push({ x: ball3.xAbs, y: bus3.y + ball3.yRel });
                if (ball3.yRel >= thrower3PosRel.y - 50 && ball3.vy > 0) {
                    ball3.yRel = thrower3PosRel.y - 50;
                    ball3.vy = 0;
                    isThrowing3 = false;
                    ball3.xAbs = bus3.x + thrower3PosRel.x;
                    ball3.vx = bus3.vx;
                }
            } else if (busMoved) {
                 ball3.xAbs = bus3.x + thrower3PosRel.x;
                 ball3.vx = bus3.vx;
            }

            drawSim3(); // Redraw with updated positions and wheel angle

            if(bus3.vx !== 0 || isThrowing3) {
                 animationFrameId3 = requestAnimationFrame(animateSim3);
            } else {
                 animationFrameId3 = null;
                 sim3Running = false;
            }
        }

         playSim3.onclick = () => { /* ... (onclick logic unchanged) ... */
            isThrowing3 = true;
            trajectory3RelBus = []; trajectory3AbsGround = [];
            ball3.yRel = thrower3PosRel.y - 50; ball3.vy = initialVelocity3;
            ball3.vx = bus3.vx; ball3.xAbs = bus3.x + thrower3PosRel.x;
            trajectory3RelBus.push({ x: thrower3PosRel.x, y: ball3.yRel });
            trajectory3AbsGround.push({ x: ball3.xAbs, y: bus3.y + ball3.yRel });
            if (!sim3Running) { animateSim3(); }
         };

         resetSim3.onclick = () => { /* ... (reset logic unchanged, now implicitly resets angle via resetSimulation3) ... */
            const wasRunning = sim3Running || bus3.vx !== 0;
            resetSimulation3(); // Resets state including wheelAngle3
            drawSim3(); // Draw the reset state
             if(wasRunning && bus3.vx !== 0 && !sim3Running) { animateSim3(); }
         };

        // --- Initial Setup ---
        resetSimulation1();
        resetSimulation2(); // Resets state including wheelAngle2
        resetSimulation3(); // Resets state including wheelAngle3
        drawSim3(); // Draws initial state for sim 3

        // Start animations if applicable
        if (bus3.vx !== 0 && !sim3Running) { animateSim3(); }
        if (bus2.vx !== 0 && !animationFrameId2) { animateSim2(); }

    </script>
    <p class="text-center text-sm text-gray-500 dark:text-gray-400">
        &copy; <span id="copyright-year"></span> NakedCircuits All rights reserved.
    </p>
</body>
</html>
